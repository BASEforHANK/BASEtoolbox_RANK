# This file has been automatically generated by PreprocessInputs.jl. Any user inputs might be overwritten!



@doc raw"""
    prepare_linearization(KSS, VmSS, VkSS, distrSS, n_par, m_par)

Compute a number of equilibrium objects needed for linearization.

# Arguments
- `KSS`: steady-state capital stock
- `n_par::NumericalParameters`,`m_par::ModelParameters`

# Returns
- `XSS::Array{Float64,1}`, `XSSaggr::Array{Float64,1}`: steady state vectors produced by [`@writeXSS()`](@ref)
- `indexes`, `indexes_aggr`: `struct`s for accessing `XSS`,`XSSaggr` by variable names, produced by [`@make_fn()`](@ref),
        [`@make_fnaggr()`](@ref)
- `n_par::NumericalParameters`,`m_par::ModelParameters`
"""
function prepare_linearization(KSS, n_par, m_par)
    # if n_par.verbose
    #     println("Running reduction step on steady-state value functions to prepare linearization")
    # end
    # ------------------------------------------------------------------------------
    # STEP 1: Evaluate StE to calculate steady state variable values
    # ------------------------------------------------------------------------------
    # Calculate other equilibrium quantities
    Paux      = n_par.Π^1000                                              # Calculate ergodic ince distribution from transitions
    distr_y   = Paux[1, :] 
    NSS       = employment(KSS, 1.0./(m_par.μ*m_par.μw), m_par)
    rSS       = interest(KSS, 1.0./m_par.μ, NSS, m_par) + 1.0 
    wSS       = wage(KSS, 1.0./m_par.μ, NSS, m_par)
    YSS       = output(KSS, 1.0, NSS, m_par)                              # stationary income distribution
    
    profitsSS = profitsSS_fnc(YSS,m_par.RB,m_par)
    unionprofitsSS  = (1.0 .- 1.0/m_par.μw) .* wSS .* NSS
    LC              = 1.0./m_par.μw *wSS.*NSS  
    # think again about how to make RANK and HANK taxes equivalent (size of profits)
    pr_scale = 1.0
    taxrev          = (LC)-m_par.τ_lev.*(LC).^(1.0-m_par.τ_prog) .+ (profitsSS - m_par.τ_lev.*(profitsSS./pr_scale).^(1.0-m_par.τ_prog) .* pr_scale)
    incgrossaux     = (LC) .+ profitsSS
    av_tax_rateSS   = dot(1.0, taxrev)./(dot(1.0,incgrossaux))
    
    # ------------------------------------------------------------------------------
    # DO NOT DELETE OR EDIT NEXT LINE! This is needed for parser.


@set! n_par.n_agg_eqn = 59
# Set aggregate steady state variabel values
ASS       = 1.0
ZSS       = 1.0
ZISS      = 1.0
μSS       = m_par.μ
μwSS      = m_par.μw
τprogSS   = m_par.τ_prog
τlevSS    = m_par.τ_lev

σSS          = 1.0
τprog_obsSS  = 1.0
GshockSS     = 1.0
RshockSS     = 1.0
TprogshockSS = 1.0

SshockSS  = 1.0
# rSS       = 1.0 + interest(KSS,1.0 / m_par.μ, NSS, m_par)
RBSS      = m_par.RB
LPSS      = 1 + rSS - RBSS
LPXASS    = 1 + rSS - RBSS
ISS       = m_par.δ_0 * KSS

πSS       = 1.0
πwSS      = 1.0

BDSS      = eps()
BSS       = m_par.BhhBAR .* YSS

# Calculate taxes and government expenditures
TSS       = dot(1.0, taxrev) + av_tax_rateSS*((1.0 .- 1.0 ./ m_par.μw).*wSS.*NSS)

# println("BSS/YSS: ", BSS/YSS)

# println("StockshareSS: ",(qΠSS_fnc(YSS,m_par.RB,m_par) .- 1.0)/BSS)
BgovSS        = BSS .- qΠSS_fnc(YSS,m_par.RB,m_par) .+ 1.0
# println("BgovSS/YSS: ", BgovSS/YSS)
GSS           = TSS - (m_par.RB./m_par.π-1.0)*BgovSS
# println("GSS/YSS: ",GSS/YSS)

mcSS      = 1.0 ./ m_par.μ


firm_profitsSS = (1.0 - mcSS) .* YSS
# println("firm_profitsSS: ", firm_profitsSS)
qΠSS      = qΠSS_fnc(YSS,RBSS,m_par)
qΠlagSS   = qΠSS
RLSS      = m_par.RB

CSS       = (YSS - m_par.δ_0 * KSS - GSS - m_par.Rbar*BDSS)
LMULTSS = ((CSS) - (NSS)^(1+m_par.γ) / (1+m_par.γ))^(-m_par.ξ)

qSS       = 1.0
mcwSS     = 1.0 ./ m_par.μw
mcwwSS    = wSS * mcwSS
uSS       = 1.0
unionprofitsSS = (1.0 - mcwSS) .* wSS .* NSS

BYSS   = BSS / YSS
TYSS   = TSS / YSS
TlagSS = TSS

YlagSS = YSS
BgovlagSS = BgovSS
GlagSS = GSS
IlagSS = ISS
wlagSS = wSS
qlagSS = qSS
ClagSS = CSS
av_tax_ratelagSS = av_tax_rateSS
τproglagSS       = τprogSS

YgrowthSS = 1.0
BgovgrowthSS = 1.0
IgrowthSS = 1.0
wgrowthSS = 1.0
CgrowthSS = 1.0
TgrowthSS = 1.0
HtSS      = 1.0

    # @include "../3_Model/input_aggregate_steady_state.jl"
    
    # write to XSS vector
    @writeXSS
    
    # produce indexes to access XSS etc.
    indexes               = produce_indexes(n_par)
    indexes_aggr          = produce_indexes_aggr(n_par)
    
    @set! n_par.ntotal    = 3 + n_par.naggr
    @set! n_par.nstates   = 2 + n_par.naggrstates 
    @set! n_par.ncontrols = 1 + n_par.naggrcontrols
    @set! n_par.LOMstate_save = zeros(n_par.nstates, n_par.nstates)
    @set! n_par.State2Control_save = zeros(n_par.ncontrols, n_par.nstates)
    @set! n_par.nstates_r   = copy(n_par.nstates)
    @set! n_par.ncontrols_r = copy(n_par.ncontrols)
    @set! n_par.ntotal_r    = copy(n_par.ntotal)
    @set! n_par.PRightStates= Diagonal(ones(n_par.nstates))
    @set! n_par.PRightAll   = Diagonal(ones(n_par.ntotal))

    if n_par.n_agg_eqn != n_par.naggr - length(n_par.distr_names)
        @warn("Inconsistency in number of aggregate variables and equations")
    end

    return XSS, XSSaggr, indexes, indexes, indexes_aggr, n_par, m_par   
end
